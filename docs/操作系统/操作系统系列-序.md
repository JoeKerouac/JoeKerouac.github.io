# 操作系统系列-序
> 这个将会是一系列文章，后续会持续更新；

> PS：本系列文章中的部分内容可能已经过时了，不过整体思路是不变的，而且也能让我们更好的了解整个操作系统的发展史；

## 前言
前段时间闲着无聊，折腾起了操作系统，主要是笔者本身不是科班出身，对于这些知识也没有系统学习过，虽然目前写起代码也没啥问题，有些东西知道可以这样搞，但是更深层次的原因就不太了解了，虽然有些内容网上也有原理讲解，但是经常会出现看过没多久就忘了，其实本质上还是对于底层逻辑不了解，导致看什么都是镜花水月、空中楼阁的感觉，很虚浮，所以就想着自行学习下操作系统相关知识，这样也可以帮助自己更好的理解编程；当然最好就是能自己动手写一个操作系统，毕竟实践是检验真理的唯一标准嘛，而且也有一句话，叫 `代码中无魔法` 。

## 工具/环境
我们在后续都会采用centos + vs code + gcc + qemu作为我们基本的开发环境，都是免费的产品，同时选用采用`AT&T`汇编；

> PS：关于汇编，目前了解到的主流的两种分别时Intel和AT&T汇编，对应的汇编器分别为NASM、gas，而Linux中主要使用了`AT&T`汇编，所以我们暂定也使用`AT&T`汇编；

> 汇编语言AT&T和Intel相当于不同的编程语言，本质上只是语法略有不同，不过大多地方都是类似的，而汇编器NASM和gas则是对应的编译器，用来将我们写的汇编编译为机器语言，供机器执行；

> qemu是一款模拟处理器的软件，用于执行、调试我们后续生成的操作系统内核；

## 操作系统是如何启动起来的
既然我们想要学习操作系统，想要写一个操作系统，首先面临的一个问题就是操作系统是如何启动的，只有知道操作系统是如何启动的，我们才有可能编写一个操作系统；


操作系统如何初始化：** 我们的电脑在上电后，会执行一系列的自检，然后BIOS初始化，最终会从所有磁盘上顺序查找，看哪个磁盘上有IPL，找到后将该磁盘的第一个扇区加载到0x7c00这个地址上，然后开始执行 **


下面我们对上边这个描述来一一解释：
> 上电自检不在我们文章的范围，这个更多是硬件层面的事情；

- 1、IPL是什么？IPL是initial program loader的缩写，即程序加载器，用于加载我们的操作系统，IPL只有512字节，实际操作系统不会这么小，根本装不进去，所以几乎所有操作系统都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也会将启动区称为IPL；
- 2、BIOS如何判断磁盘上是否有IPL？第一个问题中我们说了IPL，IPL只有512字节，在磁盘的第一个扇区，同时IPL还有一个规则，即最后两个字节必须以0x55、0xaa结束，这样BIOS就可以根据磁盘第一个扇区的最后这两个字节来判断该磁盘有没有IPL了；
- 为什么是加载到0x7c00这个地址上？如果简单理解的话，可以认为这就是最早这么规定的，这个地址来自于Intel 8088芯片，后续为了兼容就都这么干了，深入了解的话，这个也是有历史背景的，不是随便就定的，1981年IBM最早的个人电脑上市，使用的就是这个Intel 8088芯片，当时搭载的操作系统是86-DOS、这个操作系统需要的内存最少是32KB，我们都知道内存地址是从0x00开始的，32KB的内存地址范围就是0x0000-0x7fff，8088芯片本身需要占用0x0000-0x03ff这段内存，用来保存各种中断程序的存储位置，所以内存就剩0x0400-0x7fff可用，为了把尽量多的连续内存分给操作系统，IPL就被放在了内存地址的尾部，由于IPL是512字节大小，IPL本身运行时也可能会产生数据，就为其也预留了512字节的内存，这样IPL加载的位置就在 0x7fff-512-512+1=0x7c00，这就是这个位置的由来；


## 小结
本节我们介绍了一些基础概念，下节我们将尝试编写一个IPL并使其运行起来；

# 联系我
- 作者微信：JoeKerouac
- 微信公众号（文章会第一时间更新到公众号，如果搜不出来可能是改名字了，加微信即可=_=|）：代码深度研究院
- GitHub：https://github.com/JoeKerouac
