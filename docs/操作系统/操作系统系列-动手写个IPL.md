# 操作系统系列-动手写个IPL-上

在上一章中，我们简单介绍了下操作系统是如何启动的，以及`IPL`的定义，这章我们就亲自动手来写一个`IPL`的`hello world`

## IPL版hello world

俗话说的好，万事开头难，在上节中我们提到了要写一个IPL，接下来我们就准备动手来写一个`hello world`版本的IPL，然后逐渐增加功能，进行完善；

废话不多说，上代码：

> 注意，不同平台支持的指令集不同，寄存器也可能不同，如无特殊说明，后续所有代码都是针对x86平台的，如需移植其他平台请自行翻看相关平台文档；

首先，我们编写一个`boot.s`的汇编文件，内容如下：
```
.code16

movb $0x00, %ah
movb $0x03, %al
int $0x10

mov $msg, %si
call print

label:
  jmp label

print:
  movb $0xe, %ah
  call printInt
  ret

# 真实的字符串打印，逐个字符调用
printInt:
  mov (%si), %al
  add $1, %si
  cmp $0, %al
  # 如果打印完毕则返回
  je return
  int $0x10 
  jmp printInt
return:
  ret

msg:
.ascii "hello world"

.org 510
.byte 0x55, 0xaa

```


然后执行以下三个命令来编译：

```shell
as  -o boot.o boot.s
ld -e 0 -Ttext=0x7c00 -o boot.bin boot.o
objcopy -O binary -S boot.bin
```

最终执行以下命令来执行：

> 注意，qemu请自行安装，这个不是重点，后续看情况是否专门出一篇qemu如何安装的教程

> **注意，运行前请确认你的电脑是否是单核的，这个情况通常发生在虚拟机上，大部分人可能是用虚拟机搭建的环境，此时建议你给虚拟机分配至少双核，因为我们这个程序运行起来后是一个死循环，会占用一个核心，如果你的电脑/虚拟机只有一个核心那么将会变得特别卡，甚至无法响应你的任何操作！！！**

```shell
qemu-system-i386 -drive file=boot.bin,if=floppy,index=0,media=disk,format=raw -nographic -curses
```

最终你的屏幕上应该显示出来`hello world`：

![hello-world.png](../../resource/操作系统/hello-world.png)


看到这里懵逼的你可能会非常懵逼，虽然上边代码运行了起来，显示出了`hello world`，可是这是什么鬼呀，完全看不懂！！！

![懵逼.png](../../resource/操作系统/懵逼.jpg)

不要急，下面我们针对上述程序来一一讲解；


> 我们不打算一次性将汇编语言所有语法讲解清楚，只是在我们用到的时候讲下，这样可以逐步消化理解；

## 汇编讲解


### 数据类型
在我们的这段汇编程序中，我们定义了一些自定义数据，例如`.ascii "hello world"`、`.byte 0x55, 0xaa`，这些相当于我们在c语言中声明`char *str`、`int8_t number`，那汇编中有几种数据类型呢？目前常见的有如下这些（不排除还有别的）：

- .ascii：字符串；
- .asciz：以空字符结尾的字符串；
- .byte：byte value；
- .double：double value；
- .float：float value；
- .int：int value（32 bit）；
- .long：long value（32 bit）；
- .octa：16 byte integer；注意单位是byte；
- .quad：8 byte integer；注意单位是byte；
- .short：16 bit integer；
- .single：等于.float

声明的时候可以写一次数据类型，然后声明多个值，例如我们示例中的`.byte 0x55, 0xaa`，表示定义了两个byte类型的值，分别时`0x55`和`0xaa`；


### 立即数
所谓的立即数，可以单纯的理解为他就是一个数字，格式就是数字前边加一个`$`符号，例如`$0x10`就表示一个16进制的数字`0x10`，这跟我们平常用的高级语言不同，我们平常用的高级语言表示数字都是直接用`0x10`就行，那为什么汇编中要这么做呢？这是因为汇编中还会直接操作内存地址，如果不加`$`符号，那么编译器会将这个数字识别为一个内存地址而不是一个数字；

### 寄存器
在我们的这个程序中，用到了寄存器，所谓寄存器，就是CPU内部用来存储数据和运算结果的，我们的许多计算都要数据放到寄存器中，寄存器的容量非常小，而读写速度非常快，在`x86`场景下，常用的寄存器如下：

- 通用寄存器（32位）：`eax`、`ebx`、`ecx`、`edx`
- 变址寄存器（32位）：`edi`（目的变址寄存器）、`esi`（源变址寄存器）
- 指针寄存器（32位）：`ebp`（栈底寄存器）、`esp`（栈顶寄存器）
- 段寄存器（16位）：`cs`（代码段）、`ds`（数据段）、`ss`（堆栈段）、`es`（附加段）、`fs`（附加段）、`gs`（附加段）


其中`eax`、`ebx`、`ecx`、`edx`都能拆分成16位和8位寄存器使用，例如`eax`，可以拆分成`ax`（`eax`的低16位），用作16位寄存器，又可以拆分成`al`（`ax`的低8位）、`ah`（`ax`的高8位），用作8位寄存器；


`edi`、`esi`、`ebp`、`esp`则可以将开头的`e`去掉，当作16位寄存器使用（存储在对应寄存器的低16位）


当我们要引用寄存器的时候，需要加上`%`前缀，例如`%al`，表示引用`eax`这个寄存器的低8位；

### mov指令
在我们的这个`IPL`中，`mov`指令几乎是用的最多的指令了，那这个指令是做什么的呢？`mov`指令是一个传送指令，正如其名`mov(move)`，他是把一个数据从源位置复制到目标位置，例如`mov $0x00, %ah`，这个就是把`0x00`这个值放到寄存器`ah`中；


`mov`指令还有几个类似的指令：`movb`、`movw`、`movl`，这三个指令与`mov`类似，不同的是他们指定了要复制的数据长度，其中`movb`8位操作，复制一个byte，`movw`是16位操作，复制两个byte，`movl`则是32位操作，复制四个byte，如果使用了带具体后缀的`mov`指令，就只能操作具体长度的数据了，例如`movb $0xaa55, %ax`就不行，因为`movb`只能操作8位数据，而`$0xaa55`、`%ax`都是16位的；而如果使用`mov`指令就不会有这个问题，汇编器会根据后边的操作数实际大小自动处理是使用`movb`、`movw`还是`movl`；

### jmp指令
`jmp`指令也很好理解，就跟其名字`jmp(jump)`一样，是一个跳转指令，后边跟一个地址，表示我们要跳转到该地址，类似c语言的`goto`；

> 注意，`jmp`指令后边跟的是地址，不是立即数，这个要区分好；

## 小结
本章我们就先到这里，在这章中我们亲自动手写了一个IPL版的`hello world`，不过其中还有许多没有讲清楚的地方，下章我们将会继续讲解我们的这个hello world程序；如果在此过程中遇到任何困难，都可以联系作者，作者会尽力帮您答疑解惑；

# 联系我
- 作者微信：JoeKerouac
- 微信公众号（文章会第一时间更新到公众号，如果搜不出来可能是改名字了，加微信即可=_=|）：代码深度研究院
- GitHub：https://github.com/JoeKerouac

