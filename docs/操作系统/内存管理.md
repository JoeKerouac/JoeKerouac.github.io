# 操作系统内存管理机制详解

> 注意: 文中涉及的汇编是att汇编
> 本文内容基于32位x86架构，在其他架构上可能存在差异；

## 概述

操作系统的内存管理是计算机系统的核心组成部分，它负责管理和分配系统的内存资源。从早期的实模式到现代的保护模式，内存管理技术经历了显著的发展。本文将全面探讨操作系统如何在不同模式下实现内存管理。

## 地址空间的概念

在理解内存管理之前，我们需要了解几个关键的地址概念：

- **物理地址**: 物理地址是处理器可以在其地址总线上生成的地址范围，它直接部分对应于物理内存中的实际位置。
- **线性地址/虚拟地址**: 线性地址是处理器可寻址的内存空间。在没有启用分页的情况下，线性地址等同于物理地址。
- **逻辑地址**: 逻辑地址由段选择器和偏移量组成，是程序在执行时使用的地址。
- **虚拟内存**: 虚拟内存是通过分页技术实现的一种内存管理方式。在这种模式下，线性地址空间的部分不需要直接映射到物理地址空间，未映射地址的数据可以存储在外部存储设备（如磁盘）上。这种按需分页的虚拟内存机制大大提高了内存的利用效率。

> 注意，这里有一个很重要的点，实际上物理地址不等于内存地址，在物理地址（地址线）上，除了一般意义上的内存外，还有很多其他设备，例如
`ROM`（如BIOS就是在ROM中存储的）、存储控制器、网络设备等；

## 线性地址模式（8080时代）

在8080处理器时代，内存管理特点如下：

- 使用16位线性地址空间
- 直接使用物理地址，没有任何地址转换
- 最大寻址空间：64KB（2^16）
- 地址就是物理内存位置，简单直接

## 段寄存器寻址模式（8086实模式）

在8086处理器时期（1978年），首次引入了段模式，具有以下特点：

- **加入了地址转换**：使用16位段寄存器 + 16位偏移量确定内存地址；
- **地址空间限制**：只能访问1MB的内存空间（20位地址线）
- **无内存保护**：所有程序都可以访问任何内存位置
- **段式内存管理**：使用段寄存器进行内存寻址
- **段大小限制**：单个段最大64KB

### 段寄存器

实模式使用四个主要的段寄存器：

| 段寄存器   | 用途  | 描述              |
|--------|-----|-----------------|
| **CS** | 代码段 | 存储当前执行代码的段地址    |
| **DS** | 数据段 | 存储数据的默认段地址      |
| **ES** | 附加段 | 额外的数据段，常用于字符串操作 |
| **SS** | 堆栈段 | 存储堆栈的段地址        |

### 地址计算公式

实模式下的物理地址计算公式为：

```
物理地址 = 段寄存器 × 16 + 偏移地址
```

**示例：**

```assembly
; 假设 DS = 0x1000, 偏移地址 = 0x0234
; 物理地址 = 0x1000 × 16 + 0x0234 = 0x10000 + 0x0234 = 0x10234
mov %ax, 0x0234  ; 将ax寄存器的数据写入物理地址0x10234处
```

### 段重叠问题

由于段地址左移4位，不同的`段:偏移`组合可能指向同一个物理地址：

```
段地址 0x1000, 偏移 0x0234 → 物理地址 0x10234
段地址 0x1023, 偏移 0x0004 → 物理地址 0x10234
```

### 实模式下的内存布局

> 标准内存布局（1MB空间）

| 地址范围            | 大小     | 用途              |
|-----------------|--------|-----------------|
| 0x00000-0x003FF | 1KB    | 中断向量表（IVT）      |
| 0x00400-0x004FF | 256B   | BIOS数据区         |
| 0x00500-0x07BFF | ~30KB  | 可用内存区域          |
| 0x07C00-0x07DFF | 512B   | 引导扇区加载区域        |
| 0x07E00-0x9FFFF | ~608KB | 可用内存区域          |
| 0xA0000-0xBFFFF | 128KB  | 视频内存            |
| 0xC0000-0xFFFFF | 256KB  | ROM BIOS和适配器ROM |

#### 2.3.2 中断向量表（IVT）

中断向量表占用内存的前1KB（0x00000-0x003FF），包含256个中断向量，每个向量4字节：

```assembly
; 中断向量格式（4字节）
; 偏移地址（2字节） + 段地址（2字节）
; 中断号 n 的向量位置：n × 4
```

### 段寄存器寻址模式下的编程示例

```assembly
# 访问视频内存（文本模式）
video_memory:
    mov 0xB800, %ax        ; 文本模式视频内存段
    mov %ax, %es
    mov 0, %di             ; 屏幕左上角
    mov 0x0741, %ax        ; 白色背景红色前景 + 字符'A'
    mov %ax, %es:(%di)     ; 显示字符

```

## 段描述符表寻址（80286保护模式）

到了80826时代，引入了保护模式，特点如下：

- 引入了段描述符表机制，段信息不再简单地存储在段寄存器中
- 提供了基本的内存保护功能，防止不同进程间的非法内存访问
- 支持虚拟内存的基础概念
- 寻址能力从实模式的1MB扩展到16MB（24位地址总线）

### 什么是A20地址线

**A20地址线是x86架构计算机内存地址总线的第20根地址线**（从A0开始计数，A20实际上是第21根），它在早期x86处理器的内存寻址中扮演着重要角色。

> 你可能会疑惑，怎么突然蹦出来一个A20地址线，因为这是我们能访问1M以上内存的关键点，所以，我希望为你解释清楚；

#### 历史背景

##### 8086/8088时代的限制

- **Intel 8086/8088处理器**只有**20根地址线**（A0-A19）
- 最大寻址能力为 **1MB**（2^20 = 1,048,576字节）
- 内存地址范围：**0x00000 - 0xFFFFF**

##### 地址环绕现象

由于8086/8088使用16位寄存器进行分段寻址，当计算出的物理地址超过1MB时，会发生**地址环绕**

例如：对于`FFFF:FFFF`这个地址，理论上对应的物理地址是0x10FFEF（0xFFFF * 16 + 0xFFFF），但是由于只有20根地址线，实际访问的地址是
**0xFFEF**（高位被截断）

##### 兼容性问题的产生

当**80286处理器**推出时：

- 拥有**24根地址线**，可寻址**16MB**内存
- 为了向后兼容，需要模拟8086/8088的地址环绕行为
- **IBM AT机**引入了A20 Gate机制来解决这个兼容性问题

#### A20 Gate的工作原理

##### 控制机制

- A20地址线通过**A20 Gate**进行控制
- 最初使用**8042键盘控制器**的空闲引脚来控制A20线
- A20 Gate可以**开启**或**禁用**第20位地址线

##### 两种工作状态

**1. A20禁用（默认状态）**

- A20地址线被强制为0
- 模拟8086/8088的1MB地址环绕行为
- 超过1MB的地址会环绕到低地址空间

**2. A20开启**

- A20地址线正常工作
- 可以访问1MB以上的内存空间
- 必须在保护模式下才能充分利用

#### A20线的重要作用

##### 向下兼容

- 保证为8086/8088编写的程序能在新处理器上正常运行
- 维护地址环绕机制的兼容性

##### 保护模式前提

- 在80286及以后的处理器中，**进入保护模式前必须开启A20线**
- 否则无法访问1MB以上的内存空间

##### 内存访问控制

- 在实模式下防止意外访问高端内存（1MB以上）
- 提供了一种硬件级别的内存保护机制

#### 开启A20线的方法

有多种方法可以开启A20地址线，我们这里只讲通过8042键盘控制器开启的方法，虽然这种方法需要复杂的握手协议，处理速度较慢，但是兼容性好，有兴趣的可以自行了解其他开启方法；

```assembly
# 启用A20地址线，固定写法，没必要纠结具体含义
enable_a20:
  call a20wait
  mov $0xD1, %al
  out %al, $0x64
  call a20wait
  mov $0xDF, %al
  out %al, $0x60
  call a20wait
  ret
  
a20wait:
  in $0x64, %al
  test $2, %al
  jnz a20wait
  ret

```

### GDT概述

GDT（Global Descriptor Table）是段描述符表寻址的核心，GDT是IA32架构中存储段信息的数据结构，存储在内存中供CPU读取段信息。

#### 段描述符结构

GDT 表的第一个 entry 必须全为 0。GDT 中 descriptor 的结构如下图所示：

![GDT](../../resource/操作系统/GDT.png)

主要字段说明：

- **limit**：段的大小 - 1，总共 20bit；
- **base**：段的起始物理地址，总共 32bit；
- **Access Byte**：访问权限定义；
- **flags**：标志位。

> 说明：
> - `limit 0:15` 表示 limit 的低 16 位；
> - `base 0:15` 表示 base 的低 16 位；
> - `base 16:23` 表示 base 的中间 8 位；
> - `limit 16:19` 表示 limit 的高 4 位；
> - `base 24:31` 表示 base 的高 8 位。

Access Byte 与 Flags 的结构如下图所示：

![GDT-access&flgas](../../resource/操作系统/GDT-access&flags.png)

- **P（Present）**：段是否存在（1 为可用）；
- **DPL（Descriptor Privilege Level）**：2bit 特权级，0 最高，3 最低；
- **S**：描述符类型（1 为代码段/数据段，0 为系统段）；
- **Ex（Executable）**：1 表示代码段，0 表示数据段；
- **DC**：
    - 对数据段：0 为向上增长，1 为向下增长；
    - 对代码段：1 表示 `CPL ≥ DPL` 可执行，0 表示 `CPL == DPL` 才可执行；
- **RW（Readable/Writable）**：
    - 数据段：1 为可写；
    - 代码段：永远不可写；
- **Ac（Accessed）**：初始为 0，CPU 访问后置为 1；
- **Gr（Granularity）**：limit 单位，0 为字节，1 为 4KB；
- **Sz（Size）**：0 表示 16 位，1 表示 32 位保护模式

### GDTR说明

当我们在内存中定义好GDT后，需要告诉CPU去哪里找GDT，CPU提供了一个GDTR寄存器，用来让我们告诉CPU去哪里找GDT，GDTR寄存器定义如下：

| bit   | name   | description                                                                            |
|-------|--------|----------------------------------------------------------------------------------------|
| 0-15  | size   | 定义GDT的大小，单位byte，比实际大小减去了1byte，因为16bit的最大值是65535 byte（8192个 entry），而gdt表的最大值是65536 byte |
| 16-47 | offset | GDT的起始位置（注意，是物理地址）                                                                     |

### segment selector

在进入保护模式，使用段描述符表寻址机制后，原来的段寄存器就变成了段选择子，定义如下：

![segment-selector](../../resource/操作系统/segment-selector.png)

详细说明如下：

| 位    | 字段        | 描述                |
|------|-----------|-------------------|
| 0-1  | **RPL**   | 请求特权级别            |
| 2    | **TI**    | 表指示器（0为GDT，1为LDT） |
| 3-15 | **Index** | 条目索引（最多8192个条目）   |

### 地址计算公式

段描述符表下的物理地址计算公式为：

```
逻辑地址 (段选择子:偏移)
        ↓
   段选择子解析
        ↓
   查找段描述符表 (GDT/LDT)
        ↓
   获取段基地址
        ↓
   线性地址 = 段基地址 + 偏移
        ↓ 此时线性地址实际上就是物理地址
   物理地址
```

## 分页机制，段+页式混合寻址（80386及以后）

> 注意，在32位x86架构下，可以使用2级页表或者3级页表，64位x86-64架构下用的是4级页表或者5级页表， 下面我们讲的都是32位x86架构下的2级页表，其他思想类似，感兴趣的可以自行了解；

### 分页模式基本结构

在分页模式下，系统使用两个关键的数据结构：

- **页目录（Page Directory）**：包含1024个4 byte条目，总大小4KB
- **页表（Page Table）**：包含1024个4 byte条目，总大小4KB

页目录中的每个条目指向一个页表，而页表中的每个条目指向一个物理地址。地址转换通过页目录内的偏移加上页表中的偏移来计算得出。

### 页目录结构

页目录结构如下：

![页目录](../../resource/操作系统/页目录.png)

页目录中的字段说明如下：：

| 字段                      | 描述                        |
|-------------------------|---------------------------|
| **Address**             | 页表地址段，表示对应页表的物理地址（4KB对齐）  |
| **S (Page Size)**       | 页面大小标志，设置后页面大小为4MB，否则为4KB |
| **A (Accessed)**        | 访问标志，页面被读取或写入时设置          |
| **D (Cache Disable)**   | 缓存禁用标志，设置后不缓存该页           |
| **W (Write-through)**   | 写通标志，控制缓存写入策略             |
| **U (User/Supervisor)** | 用户/管理员访问权限标志              |
| **R (Read/Write)**      | 读写权限标志                    |
| **P (Present)**         | 存在标志，表示页面是否在物理内存中         |


### 页表结构

页表结构如下：

![页表结构](../../resource/操作系统/页表结构.png)

页表条目的结构与页目录类似，这里列出差异字段：

| 字段             | 描述                                                                                                                                                                                                                    |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Address**    | 4KB对齐的物理地址，也页目录不同的是，这里的地址指向的是4KB的物理块                                                                                                                                                                                  |
| **C (cached)** | 来自钱一个表的D位                                                                                                                                                                                                             |
| **G (Global)** | 全局标志，防止在CR3更新时TLB刷新缓存                                                                                                                                                                                                 |
| **D (Dirty)**  | 脏页标志，设置该标志标识页面已经被写入，该标志不会被CPU更新，一旦设置将不会自行取消设置；只对file backed的page有意义，当page被写入时硬件将该位置为1，表明该page的内容比外部（disk/flash）对应的部分要新，当系统内存不足需要回收内存时如果该位为1需要将该page对应的内存的内容刷新到disk/flash，然后将该位清0，之后改page对应的内存就可以释放了（可能还有其他操作，例如设置P位）  |

> 这里你有没有疑惑，32位系统支持4G内存，但是这里的地址字段只有20位，岂不是只能访问1M内存吗？不要忘了，这里的地址指向的是4K内存块，是将物理地址按照4K分割为一个大表，页表中的地址指向的是一个个4K地址段的index，并不是物理地址，所以最终页表能管理的内存就是4G，而不是1M；

### 整体结构示意图

![分页整体结构](../../resource/操作系统/分页整体结构.png)

### 分页机制的启用

开启分页很简单，只需要将页目录的地址加载到CR3，同时设置CR0的分页（PG）和保护（PE）位即可，注意，如果清除了保护位但是设置分页位将会导致一般保护异常（general-protection exception），代码如下：

```assembly
# 将页目录地址放入CR3，注意，这里的page_directory是页目录的物理地址，需要自行初始化页目录和页表
mov page_directory, %eax
mov %eax, %cr3

# 设置CR0的PG和PE位
mov %cr0, %eax
or $0x80000001, %eax  # PG位(bit 31) 和 PE位(bit 0)
mov %eax, %cr0
```


### 启用分页后的地址转换过程

开启分页后，虚拟地址被分解为：

- **高10位**：页目录索引
- **中间10位**：页表索引
- **低12位**：页内偏移

> 正是这个机制限制，页目录最大只能有1024项，页表最大只能有1024项，一个页只能有4K，因为页目录索引和页表索引只有10位，地址位（页内偏移）只有12位；

地址转换步骤：

- 1. 从CR3寄存器获取页目录物理地址
- 2. 使用虚拟地址高10位在页目录中找到对应条目
- 3. 根据页目录条目找到页表地址
- 4. 使用虚拟地址中间10位在页表中找到对应条目
- 5. 将页表条目的高20位与虚拟地址的低12位组合成物理地址


逻辑地址到物理地址的完整转换流程图：

> 因为启用分页前必须启用分段，所以地址转换需要先经过GDT/LDT转换，然后在经过页表转换，最终才得到物理地址；

```
逻辑地址 (段选择子:偏移)
        ↓
   段选择子解析
        ↓
   查找段描述符表 (GDT/LDT)
        ↓
   获取段基地址
        ↓
   线性地址 = 段基地址 + 偏移
        ↓
   页表转换
        ↓
   物理地址
```

逻辑地址到物理地址的转换详情图：

![逻辑地址到物理地址的转换](../../resource/操作系统/逻辑地址到物理地址的转换.png)


### 二级分页的优势
看到这里，我猜聪明的你肯定会想，为什么32位x86架构要使用二级分页，而不是更简单的将所有页表平铺的一级分页呢？使用一级分页结构直接就能找到对应的页表，而不是还要经过页目录到页表的转换，不是更麻烦了吗？下面我们就简单介绍下二级分页相对于一级分页的优势；

#### 内存效率

- **一级分页**：每个进程需要2^20个表项（4M连续空间），无论程序本身需要多大内存，启动后页表本身就需要4M内存，对于一些简单的程序，页表可能比程序内存占用还要大；
- **二级分页**：每个进程只需2^10个一级表项（4K连续空间），二级表项按需创建，分页占用最小只需要8K空间（4K页目录+页目录中第一个4K页表，总共8K）；

#### 空间利用

二级分页能够：

- 利用更零散的内存空间，因为页目录和页表是分开存的，最小只需要4K连续空间即可存储一个页目录或者页表，而多个页表之间无需连续的内存空间；
- 减少内存碎片
- 提高内存利用率


## TLB（Translation Lookaside Buffer）

### TLB的作用

TLB是地址转换的硬件缓存，用于加速虚拟地址到物理地址的转换过程。它缓存最近使用的页表项，避免每次地址转换都要访问内存中的页表。

### TLB的特点

- **容量**：通常能存储8-4096个页表项
- **命中率**：由于程序的局部性原理，TLB命中率通常很高
- **刷新机制**：在x86架构中，CR3寄存器更新时会强制刷新TLB

### 多进程环境下的TLB管理

不同进程使用不同的页表，相同的虚拟地址可能对应不同的物理地址。x86架构采用简单的强制刷新策略（这也会导致进程切换的成本增高），而其他架构可能使用进程ID标识或软件管理的方式。

## 总结

操作系统的内存管理通过分段和分页机制实现了：

1. **虚拟内存管理**：允许程序使用超过物理内存大小的地址空间
2. **内存保护**：通过权限位确保进程间的内存隔离
3. **高效的地址转换**：通过TLB缓存加速地址转换过程
4. **灵活的内存分配**：二级分页提供了更好的内存利用率

这些机制共同构成了现代操作系统内存管理的基础，为多任务操作系统提供了稳定、高效的内存管理服务。

# 联系方式

- 微信：JoeKerouac
- 微信公众号：代码深度研究院（如搜不到可添加微信获取）
- GitHub：[https://github.com/JoeKerouac](https://github.com/JoeKerouac)

