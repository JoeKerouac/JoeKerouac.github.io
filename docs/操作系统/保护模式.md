# 保护模式保护了个啥

在我们日常使用的操作系统中，处理器默默地以一种被称为“保护模式（Protected Mode）”的方式运行。这种模式自80286处理器起引入，是现代多任务、多用户操作系统的基础之一。但是，你有没有想过它到底保护了什么、又是如何保护的？

## 实模式的局限：操作系统的前世

在早期的 8086 架构中，CPU 运行在所谓的“实模式（Real Mode）”下，这种模式下：

- 地址总线仅支持 1MB 空间；
- 内存地址访问几乎不加限制，任何程序都可以访问任意内存；
- 没有权限控制，用户程序可以覆盖操作系统内核；
- 不支持虚拟内存、任务切换、多用户。

**一言以蔽之：危险、脆弱、原始。**

在这种环境下运行复杂的系统几乎是天方夜谭，于是，保护模式应运而生。

## 保护内容
保护模式保护了以下几个方面：

- 类型检查
- 越界检查（通过base、limit）
- 寻址域限制
- 程序入口点限制
- 指令集限制：
  - cli/sti: 关闭、开启中断
  - hlt: 挂起CPU，等待中断
  - lgdt/lidt/lldt: 设置GDT、IDT、LDT
  - ltr: 加载任务状态段（TSS）选择子
  - mov CRx: 读写控制寄存器 CR0–CR4
  - iret: 从中断返回（恢复 CS/EIP/EFLAGS）
  - ...其他特权指令

## 内存保护

保护模式最根本的功能，是内存保护，上边的类型检查、越界检查、寻址域检查、程序入口点限制本质上都是对内存的保护，都是基于GDT来实现的

在保护模式下，每个程序只能访问自己分配到的内存区域，借助段描述符（Segment Descriptors）和页表机制（Paging），CPU 可做到：

- 用户态程序无法访问内核空间；
- 不同进程之间互不干扰；
- 防止缓冲区溢出影响系统其它部分。

🧠 通俗理解：每个程序都在自己的“安全沙箱”中运行。

## 虚拟内存支持

保护模式支持分页机制，让每个进程拥有自己的虚拟地址空间。这意味着：

- 操作系统可以使用比物理内存更大的空间；
- 进程之间无法感知彼此的存在；
- 增强了系统的稳定性和安全性。

有了虚拟内存，才有今天“一个程序崩了不会蓝屏”的体验。

## 特权级别



## 具体实现
首先，我们需要知道，x86 架构引入了 四个特权级（Ring 0 ~ Ring 3），其中：

- Ring 0：内核态，拥有最高权限；
- Ring 3：用户态，权限最低。


然后，我们要简单认识下GDT（Global Descriptor table），GDT是IA32架构中的结构，存储在内存中，用来保存段信息，CPU会从这里边读取段信息；注意，GDT表的基址最好是8byte对齐的，这样性能最好，不过并没有强制要求，即使不是8byte对齐也能运行；

GDT中存储的descriptor结构如下（GDT表的第一个entry的数据必须是全0）：

![GDT](../../resource/操作系统/GDT.png)

其中包含以下部分：
- limit：该段的大小，总共20bit（limit 0 表示有一个页，1表示有两个页，2表示有三个页，页的粒度大小由flags中的Gr字段决定）
- base：该段的起始位置（真实的物理地址位置），总共32bit
- Access byte：访问权限相关定义
- flags：标签

> 其中limit 0:15 表示 limit 字段的低 16 bit，base 0:15 表示base字段的低16 bit，base 16: 23 表示base字段的中间8bit，limit 16:19 表示limit的高 4bit，base 24:31 表示base字段的高8bit；

其中access byte和flags结构和字段说明如下：

![GDT-access&flgas](../../resource/操作系统/GDT-access&flags.png)

- pr：对于可用的段必须是1，如果是0表示该段不可用，如果访问会直接抛异常；
- privl（2bit）：特权字段，0-3四个值，0表示最大特权，3表示最小特权；这个叫DPL；
- S：GDT类型，如果是数据段或者代码段应该设置为1，如果是system segments则设置为0；
- Ex：是否可执行标志字段，如果段中存储的是代码则设置为1，如果存储的是数据则设置为0；
- DC：
  - 对于数据段，0表示向上增长，1表示向下增长
  - 对于代码段，如果设置为1，表示可以被低于该段权限的访问者访问；0则表示只能被同权或者更高权限执行；
- RW：读写标志位，1表示可读写，0表示不可读写，对于代码段，永远不允许写操作，对于数据段，永远允许读操作；
- Ac：只需要设置为0即可，CPU访问过会自动将其设置为1；
- Gr（granularity）：limit的单位，如果为0，则limit的单位为byte，如果为1，则limit的单位为4K；
- Sz：如果0则表示是16位保护模式，如果是1则表示是32位保护模式；

CPU中有一类寄存器叫段寄存器，单个段寄存器大小16bit，在保护模式下，段寄存器存储的数据变为了段选择子，用于索引GDT或者LDT，其中16bit的作用分别如下：

- bit 0-1：这两个bit描述特权级别；
- bit 2：指示使用GDT还是LDT，0表示GDT，1表示LDT
- bit 3-15：表示GDT表的偏移量，0表示第一个entry，1表示第二个entry，每个entry的大小都是64bit（包含一个完整的descriptor）

保护模式能实现保护的一大重点就在特权级别上，在系统中，会存在3处描述特权级别的地方：

- 在GDT/LDT中定义的特权级别（上边的`privl`字段），这个通常叫DPL；
- 在数据段寄存器（段选择子）中定义的特权级别，通常叫RPL；
- 在CS寄存器中定义的特权级别，通常叫CPL；

CPU会在两个关键点上保护内存：

- 当一个段选择子被加载时；
- 当通过线性地址访问一个内存页时；

段选择子被加载时的校验：

![段选择子](../../resource/操作系统/段选择子.png)

注意：MAX就是字面意义的取最大值，因为值越大特权级别越小，所以实际上这里是需要CPL和RPL中特权等级最低的一个级别也要大于等于DPL


## 结语
“保护模式”并不是为用户加了一层密码，而是为操作系统和 CPU 本身建立了“纪律”与“边界”。

它保护了：

- 内核的神圣不可侵犯；
- 程序间的互不干扰；
- 系统的稳定运行；
- 安全机制的硬件支撑。

在这个日益复杂和多任务并存的世界中，保护模式无声地支撑着计算机的稳定运行，是操作系统时代从“混沌”迈入“秩序”的一次飞跃。

# 联系我

- 作者微信：JoeKerouac
- 微信公众号（文章会第一时间更新到公众号，如果搜不出来可能是改名字了，加微信即可=_=|）：代码深度研究院
- GitHub：https://github.com/JoeKerouac


