# 保护模式保护了个啥

在我们日常使用的操作系统中，处理器默默地以一种被称为“保护模式（Protected Mode）”的方式运行。这种模式自80286处理器起引入，是现代多任务、多用户操作系统的基础之一。但是，你有没有想过它到底保护了什么、又是如何保护的？

## 实模式的局限：操作系统的前世

在早期的 8086 架构中，CPU 运行在所谓的“实模式（Real Mode）”下，这种模式下：

- 地址总线仅支持 1MB 空间；
- 内存地址访问几乎不加限制，任何程序都可以访问任意内存；
- 没有权限控制，用户程序可以覆盖操作系统内核；
- 不支持虚拟内存、任务切换、多用户。

**一言以蔽之：危险、脆弱、原始。**

在这种环境下运行复杂的系统几乎是天方夜谭，于是，保护模式应运而生。

## 保护内容
保护模式保护了以下几个方面：

- 类型检查
- 越界检查（通过base、limit）
- 寻址域限制
- 程序入口点限制
- 指令集限制：保护模式通过硬件级的权限控制（特权指令和内存访问控制），确保只有内核态代码可以执行敏感操作。
  - cli/sti: 关闭、开启中断
  - hlt: 挂起CPU，等待中断
  - lgdt/lidt/lldt: 设置GDT、IDT、LDT
  - ltr: 加载任务状态段（TSS）选择子
  - mov CRx: 读写控制寄存器 CR0–CR4
  - iret: 从中断返回（恢复 CS/EIP/EFLAGS）
  - ...其他特权指令

## 内存保护

保护模式的功能之一，是内存保护，上边的类型检查、越界检查、寻址域检查、程序入口点限制本质上都是对内存的保护，都是基于GDT来实现的；

在保护模式下，每个程序只能访问自己分配到的内存区域，借助段描述符（Segment Descriptors）和页表机制（Paging），CPU 可做到：

- 用户态程序无法访问内核空间；
- 不同进程之间互不干扰；
- 防止缓冲区溢出影响系统其它部分。

🧠 通俗理解：每个程序都在自己的“安全沙箱”中运行。

## 虚拟内存支持

保护模式支持分页机制，让每个进程拥有自己的虚拟地址空间。这意味着：

- 操作系统可以使用比物理内存更大的空间；
- 进程之间无法感知彼此的存在；
- 增强了系统的稳定性和安全性。

有了虚拟内存和内存隔离机制，即使一个用户态程序崩溃，也不会影响整个系统的稳定性。

## 具体实现
首先，我们需要知道，x86 架构引入了 四个特权级（Ring 0 ~ Ring 3），其中：

- Ring 0：内核态，拥有最高权限；
- Ring 3：用户态，权限最低。


然后，我们要简单认识下GDT（Global Descriptor table），GDT是IA32架构中的结构，存储在内存中，用来保存段信息，CPU会从这里边读取段信息；注意，GDT表的基址最好是8byte对齐的，这样性能最好，不过并没有强制要求，即使不是8byte对齐也能运行；

GDT中存储的descriptor结构如下（GDT表的第一个entry的数据必须是全0）：

![GDT](../../resource/操作系统/GDT.png)

其中包含以下部分：
- limit：等于该段的大小-1，总共20bit；
- base：该段的起始位置（真实的物理地址位置），总共32bit
- Access byte：访问权限相关定义
- flags：标签

> 其中limit 0:15 表示 limit 字段的低 16 bit，base 0:15 表示base字段的低16 bit，base 16: 23 表示base字段的中间8bit，limit 16:19 表示limit的高 4bit，base 24:31 表示base字段的高8bit；

其中access byte和flags结构和字段说明如下：

![GDT-access&flgas](../../resource/操作系统/GDT-access&flags.png)

- pr：对于可用的段必须是1，如果是0表示该段不可用，如果访问会直接抛异常；
- privl（2bit）：特权字段，0-3四个值，0表示最大特权，3表示最小特权；这个叫DPL；
- S：GDT类型，如果是数据段或者代码段应该设置为1，如果是system segments则设置为0；
- Ex：是否可执行标志字段，如果段中存储的是代码则设置为1，如果存储的是数据则设置为0；
- DC：
  - 对于数据段，0表示向上增长，1表示向下增长
  - 对于代码段，如果设置为1，表示**更高或等于当前特权级别**（`CPL ≥ DPL`）都可以执行，0则表示**只有`CPL == DPL`**的代码可以执行；
- RW：读写标志位，1表示可读写，0表示不可读写，对于代码段，永远不允许写操作，对于数据段，永远允许读操作；
- Ac：只需要设置为0即可，CPU访问过会自动将其设置为1；
- Gr（granularity）：limit的单位，如果为0，则limit的单位为byte，如果为1，则limit的单位为4K；
- Sz：如果0则表示是16位保护模式，如果是1则表示是32位保护模式；

CPU中有一类寄存器叫段寄存器，单个段寄存器大小16bit，在保护模式下，段寄存器存储的数据变为了段选择子，用于索引GDT或者LDT，其中16bit的作用分别如下：

- bit 0-1：这两个bit描述特权级别；
- bit 2：指示使用GDT还是LDT，0表示GDT，1表示LDT
- bit 3-15：表示GDT表的偏移量，0表示第一个entry，1表示第二个entry，每个entry的大小都是64bit（包含一个完整的descriptor）

> 注意，这里的bit0-15是从低到高的，也就是说bit 0-1指的是最低两位；；

保护模式能实现保护的一大重点就在特权级别上，在系统中，会存在3处描述特权级别的地方：

- 在GDT/LDT中定义的特权级别（上边的`privl`字段），这个通常叫DPL；
- 在数据段寄存器（段选择子）中定义的特权级别，通常叫RPL；
- 在CS寄存器中定义的特权级别，通常叫CPL；

CPU会在两个关键点上保护内存：

- 当一个段选择子被加载时；
- 当通过线性地址访问一个内存页时；

段选择子被加载时的校验：

![段选择子](../../resource/操作系统/段选择子.png)

> 注意：MAX就是字面意义的取最大值，因为值越大特权级别越小，所以实际上这里是需要CPL和RPL中特权等级最低的一个级别也要大于等于DPL

> 对于代码段访问，使用 max(CPL, RPL) ≤ DPL 判断是否允许；但对于数据段访问还需要检查读/写权限位等其他控制字段。

# 联系我

- 作者微信：JoeKerouac
- 微信公众号（文章会第一时间更新到公众号，如果搜不出来可能是改名字了，加微信即可=_=|）：代码深度研究院
- GitHub：https://github.com/JoeKerouac


