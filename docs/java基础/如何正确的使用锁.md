# 如何正确的使用锁

> 最近在接手的系统中碰到了好几个因为锁用错导致的bug，总结下问题，讨论下如何正确的使用锁；

锁是一种用于协调多个线程或进程对共享资源访问的机制。正确地使用锁，可以有效避免数据竞争和不一致性，提高系统的稳定性和可靠性。本文将围绕以下几个方面，介绍如何正确地使用锁。

---

## 为什么要使用锁

在多线程或分布式系统中，多个线程或进程可能会同时访问共享资源，例如内存变量、数据库记录或缓存数据。如果没有恰当的机制来协调这些访问，就可能导致以下问题：
- **数据竞争**：多个线程同时修改同一资源，导致数据不一致。
- **脏读问题**：一个线程读取了另一个线程未提交的修改，导致数据错误。

锁的本质是通过“互斥”来保障共享资源的访问安全，确保在同一时间只有一个线程能够对资源进行操作。

---

## 哪些场景需要使用锁

锁通常在以下场景下使用：
1. **共享资源的修改**：当多个线程需要同时修改同一个变量或对象时，需要使用锁来保护资源的完整性。
    - 例如：多线程操作一个计数器变量。
2. **临界区操作**：当一个代码块需要以原子方式执行时，需要使用锁。
    - 例如：读取和写入缓存的逻辑。
3. **分布式系统的关键操作**：当多个节点需要协调操作时，锁是必不可少的同步工具。
    - 例如：分布式事务的执行。


---

## 常见锁类型都有哪些

锁的种类有很多种，以下是常见的几类锁以及它们的使用方法：

### 1. Java 内存锁
Java 提供了多种内存锁机制：
- **`synchronized` 关键字**：
    - 用于实现线程间的互斥访问。
    - 示例代码：
      ```java
      public synchronized void increment() {
          counter++;
      }
      ```
- **`JUC包提供的各种锁`**：
    - 提供了更灵活的锁操作，例如可以尝试加锁或设置超时时间。
    - 示例代码：
      ```java
      ReentrantLock lock = new ReentrantLock();
      lock.lock();
      try {
          counter++;
      } finally {
          lock.unlock();
      }
      ```

注意：如果并发不高，或者对锁的需求比较复杂，比如需要获取锁失败时立即返回或者在一段时间内获取失败立即返回、读写锁分离等，推荐使用JUC，否则优先推荐synchronized关键字实现锁，在并发高的场景性能更优；


### 2. 数据库行锁
如果你需要分布式锁，那么数据库行锁就是一个很好的可选项，在数据库操作中，行锁可以用来防止数据竞争：

- **悲观锁**：
    - 在读取数据时直接加锁，防止其他事务修改。
    - 示例代码（以 MySQL 为例）：
      ```sql
      SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
      ```
- **乐观锁**：
    - 不直接加锁，而是在更新时检查数据是否被其他事务修改过。
    - 示例代码：
      ```sql
      UPDATE table_name 
      SET value = value + 1 
      WHERE id = 1 AND version = 1;
      ```

注意：乐观锁大多数场景下不推荐，除非你的并发不高，并且有良好的失败策略（加锁失败后如何处理）；

### 3. Redis 锁
在分布式系统中，Redis 的分布式锁也是一种常见选择：

- **实现方式**：
  使用 `SETNX` 或 `Redisson` 来实现分布式锁。
- **示例代码（简单实现）**：
  ```java
  String lockKey = "lock:resource";
  String requestId = UUID.randomUUID().toString();
  boolean locked = jedis.set(lockKey, requestId, "NX", "PX", 30000);
  if (locked) {
      try {
          // 执行关键操作
      } finally {
          if (requestId.equals(jedis.get(lockKey))) {
              jedis.del(lockKey);
          }
      }
  }
  ```

注意：要实现一个可靠的redis锁很难，有兴趣的可以参考redis官方关于redlock的描述，或者参考历史文章，好在Java开源生态很好，你可以直接选用redisson框架使用它提供的redis锁，可以像使用JUC包中的锁一样简单方便；但是redis锁相对于Java内存锁和数据库仍然是一个相当复杂的工程；

---

## 使用锁的注意事项

1. **避免死锁**：
    - 要确保加锁的顺序一致，避免多个线程互相等待资源。
    - 使用超时机制，例如 `ReentrantLock.tryLock()`。

2. **减少锁的粒度**：
    - 锁的范围越小，性能开销越低。尽量将锁的逻辑控制在最小的代码块。

3. **选择合适的锁机制**：
    - 本地线程建议使用 `synchronized` 或 `ReentrantLock`。
    - 分布式环境建议使用 Redis 或 Zookeeper 锁。

4. **锁的释放**：
    - 加锁后一定要确保释放锁，建议在 `try-finally` 块中完成锁的释放。

5. **性能权衡**：
    - 锁的使用会带来额外的性能开销，对于读多写少的场景，可以考虑无锁优化。

---

## 一个用锁原则
一个经典的用锁原则：一锁二判三更新：

- 1、**加锁**：锁定资源（可以是数据库记录，也可以是redis中的数据、分布式文件系统中的文件等），确保操作的唯一性。
- 2、**判断**：根据资源状态决定是否继续操作。
- 3、**更新**：执行更新资源操作并释放锁，确保数据一致性。



## 我应该何时使用锁，怎么用

对于该问题，可以简单分为以下几个阶段

### 是否需要锁
在该阶段，通常你不能很好的分辨对于某个场景是否要用锁，此时应该优先保证业务的正确性，而不是其他（例如性能）；

如果你对某个场景是否要使用锁感到困惑，那就用，有的人可能担心使用锁造成性能损失，但是用锁造成的性能损失总好过于不用锁造成的业务异常甚至是资金损失；对于要用锁的场景，没有用锁，通常很小的并发就有可能导致数据异常，但是对于不该用锁的场景，用了锁，一般都要在很大的并发下才会有性能影响，而且，相信我，如果你的业务对性能敏感到要尽可能优化锁的使用甚至是寻求无锁结构，那这绝对不是现阶段的你能搞定的，你应该寻求其他人的帮助；

- 风险对比：
    - 不加锁可能导致数据异常，甚至资金损失。
    - 加锁的性能损失通常只在高并发下才会显现。

### 能否正确使用锁
当我们能正确分辨哪些场景需要使用锁，那些场景不需要使用锁后，需要继续考虑的就是如何用对锁；

如果锁用不对，不如不用，而怎么用对锁，是一个很复杂的问题，我曾经在项目中见过对于同一个资源操作的两个入口，一个加了锁，一个没加锁，最终导致锁失效，也见过对于同一个资源操作的两个入口，都加了锁，但是加的锁维度完全不同导致无法互斥，最终锁失效，所以，如果想要用对锁，一定要保证对于同一个资源的操作所有入口需要添加相同粒度、相同维度的锁，同时遵守我们上边的一锁二判三更新的用锁原则，这个虽然看起来很简单，但是在大型分布式项目中和历史较长的项目中经常出问题，需要注重注意；


### 进阶阶段
在该阶段，你通常能很好的分辨某个场景是否要用锁，为什么要用锁，此时要考虑的事情就是如何在合适的场景使用合适的锁，尽可能保证锁的粒度小，甚至不用锁，保证对性能的损失更小；

通常，对于上边提到的三种类型的锁，优先建议使用内存锁，如果内存锁满足不了需求，需要分布式锁，那么优先考虑数据库锁（悲观锁），如果数据库锁也满足不了业务的需求（通常数据库锁已经能满足绝大多数场景了），此时再考虑redis锁或者其他锁，甚至其他奇奇怪怪大的分布式锁，例如使用zookeeper实现的分布式锁，没错，我曾经在接手的某些项目中见过用zookeeper实现的锁；

在考虑用什么锁的时候，记住一个原则，尽可能少的引入外部依赖，如果你的系统本身依赖数据库，不依赖redis，非必要不要引入redis，如果你的系统本身不依赖数据库，但是依赖redis，那么非必要不要引入数据库，越少的外部依赖系统稳定性越容易提高，上限越高；

---



通过合理地选择锁的类型和使用方式，可以有效地提升系统的并发性能并保证数据的一致性。在实际项目中，需要根据具体需求权衡锁的使用成本与收益。

# 联系我
- 作者微信：JoeKerouac
- 微信公众号（文章会第一时间更新到公众号，如果搜不出来可能是改名字了，加微信即可=_=|）：代码深度研究院
- GitHub：https://github.com/JoeKerouac

