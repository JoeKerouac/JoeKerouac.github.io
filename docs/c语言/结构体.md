## 结构体声明
### 声明方式1
```
struct user{
  char sex;
  int age;
};
```
#### 结构体内存对齐规则
在上述结构体中，如果使用sizeof来获取结构体的大小，那么得到的结果将是8而不是5，因为存在内存对齐规则，规则如下：

- 1.结构体的起始存储位置必须是能够被该结构体中最大的数据类型所整除。
- 2.每个数据成员存储的起始位置是自身大小的整数倍(比如int在32位机为4字节，则int型成员要从4的整数倍地址开始存储)。
- 3.结构体总大小（也就是sizeof的结果），必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。
- 4.结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储。(比如struct a里存有
struct b，b里有char,int,double等元素,那b应该从8的整数倍开始存储。)
- 5.结构体包含数组成员，比如`char a[3]`,它的对齐方式和分别写3个char是一样的，也就是说它还是按一个字节对齐。如果写：
`typedef char Array[3]`,Array这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。
- 6.结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储

上边是完整规则，简化后如下：

- 规则一：前面单元的大小必须是后面单元大小的整数倍，如果不是就补齐；
- 规则二：整个结构体的大小必须是最大字节的整数倍；

#### 内存分析1
对下面结构体进行内存分析
```
struct user{
  char a;
  int b;
  char c;
};
```
上述结构体内存结构如下：

| 内存地址 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 存放数据 | a | | | | b | b | b | b | c | | | |

首先起始位置是a的数据，然后因为后边b的大小是4位，所以这里除了a占一位外还要有三位空字节填充，然后是b的数据，然后是c的数据，根据规则一来
判断前边b的长度是4位，c的长度是1位，满足条件，但是根据规则二来判断，整体长度是9位，不是最长的b的整数倍，所以这里要填充三位，所以该结构体
总大小是12；

#### 内存分析2
对下面结构体进行内存分析
```
struct user{
  char a;
  char b;
  int c;
};
```
上述结构体内存结构如下：

| 内存地址 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 存放数据 | a | b | | | c | c | c | c |

首先起始位置是a的数据，然后根据简化规则一，前边长度是1位是b数据大小1位的整数倍，所以直接填充b，然后根据规则一，因为c的长度是4位，前边ab
总共是两位，不是4的整数倍，需要填充两位，然后填充c，此时发现内存结构已经满足规则二了，不需要再填充了，所以最终内存结构如上，最终该结构体
使用sizeof得到的大小将会是8；

### 声明方式2
```
struct user{
  char sex;
  int age;
} __attribute__ ((__packed__));
```
该结构体因为后边有`__attribute__ ((__packed__))`关键字，所以不会进行对齐，所以对该结构体使用sizeof函数得到的大小将会是5而不是8；